{"version":3,"file":"interacto.es5.js","sources":["../node_modules/rxjs/src/internal/util/isFunction.ts","../node_modules/rxjs/src/internal/util/createErrorClass.ts","../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../node_modules/rxjs/src/internal/util/arrRemove.ts","../node_modules/rxjs/src/internal/Subscription.ts","../node_modules/rxjs/src/internal/config.ts","../node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts","../node_modules/rxjs/src/internal/util/reportUnhandledError.ts","../node_modules/rxjs/src/internal/util/noop.ts","../node_modules/rxjs/src/internal/util/errorContext.ts","../node_modules/rxjs/src/internal/Subscriber.ts","../node_modules/rxjs/src/internal/symbol/observable.ts","../node_modules/rxjs/src/internal/util/identity.ts","../node_modules/rxjs/src/internal/util/pipe.ts","../node_modules/rxjs/src/internal/Observable.ts","../node_modules/rxjs/src/internal/util/lift.ts","../node_modules/rxjs/src/internal/operators/OperatorSubscriber.ts","../node_modules/rxjs/src/internal/operators/refCount.ts","../node_modules/rxjs/src/internal/observable/ConnectableObservable.ts","../node_modules/rxjs/src/internal/scheduler/performanceTimestampProvider.ts","../node_modules/rxjs/src/internal/scheduler/animationFrameProvider.ts","../node_modules/rxjs/src/internal/observable/dom/animationFrames.ts","../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../node_modules/rxjs/src/internal/Subject.ts","../node_modules/rxjs/src/internal/BehaviorSubject.ts","../node_modules/rxjs/src/internal/scheduler/dateTimestampProvider.ts","../node_modules/rxjs/src/internal/ReplaySubject.ts","../node_modules/rxjs/src/internal/AsyncSubject.ts","../node_modules/rxjs/src/internal/scheduler/Action.ts","../node_modules/rxjs/src/internal/scheduler/intervalProvider.ts","../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../node_modules/rxjs/src/internal/util/Immediate.ts","../node_modules/rxjs/src/internal/scheduler/immediateProvider.ts","../node_modules/rxjs/src/internal/scheduler/AsapAction.ts","../node_modules/rxjs/src/internal/Scheduler.ts","../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts","../node_modules/rxjs/src/internal/scheduler/asap.ts","../node_modules/rxjs/src/internal/scheduler/async.ts","../node_modules/rxjs/src/internal/scheduler/QueueAction.ts","../node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts","../node_modules/rxjs/src/internal/scheduler/queue.ts","../node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts","../node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts","../node_modules/rxjs/src/internal/scheduler/animationFrame.ts","../node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts","../node_modules/rxjs/src/internal/observable/empty.ts","../node_modules/rxjs/src/internal/Notification.ts","../node_modules/rxjs/src/internal/util/EmptyError.ts","../node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts","../node_modules/rxjs/src/internal/util/NotFoundError.ts","../node_modules/rxjs/src/internal/util/SequenceError.ts","../node_modules/rxjs/src/internal/operators/timeout.ts","../node_modules/rxjs/src/internal/observable/never.ts"],"sourcesContent":["/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n","/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subcription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n","type SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => number;\ntype ClearTimeoutFunction = (handle: number) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const {delegate} = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle);\n  },\n  delegate: undefined,\n};\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: observerOrNext ?? undefined,\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n","/** Symbol.observable or a string \"@@observable\". Used for interop */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: Partial<Observer<T>>): Subscription;\n  subscribe(next: (value: T) => void): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * ## Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n","import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n","import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n","import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n","import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n","import { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  const { schedule } = animationFrameProvider;\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    const subscription = new Subscription();\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n    const run = (timestamp: DOMHighResTimeStamp | number) => {\n      // Use the provider's timestamp to calculate the elapsed time. Note that\n      // this means - if the caller hasn't passed a provider - that\n      // performance.now() will be used instead of the timestamp that was\n      // passed to the run callback. The reason for this is that the timestamp\n      // passed to the callback can be earlier than the start time, as it\n      // represents the time at which the browser decided it would render any\n      // queued frames - and that time can be earlier the captured start time.\n      const now = provider.now();\n      subscriber.next({\n        timestamp: timestampProvider ? now : timestamp,\n        elapsed: now - start,\n      });\n      if (!subscriber.closed) {\n        subscription.add(schedule(run));\n      }\n    };\n    subscription.add(schedule(run));\n    return subscription;\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create customize Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n","import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n","import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple fo exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param bufferSize The size of the buffer to replay on subscription\n   * @param windowTime The amount of time the buffered items will say buffered\n   * @param timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","type SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => number;\ntype ClearIntervalFunction = (handle: number) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const {delegate} = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle);\n  },\n  delegate: undefined,\n};\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: any;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: any, delay: number = 0): any {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id: any, delay: number | null = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    intervalProvider.clearInterval(id);\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n","let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n","import { Immediate } from '../util/Immediate';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => number;\ntype ClearImmediateFunction = (handle: number) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle);\n  },\n  delegate: undefined,\n};\n","import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    if (!scheduler.actions.some((action) => action.id === id)) {\n      immediateProvider.clearImmediate(id);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  public _scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: QueueScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return (delay > 0 || this.closed) ?\n      super.execute(state, delay) :\n      this._execute(state, delay) ;\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Otherwise flush the scheduler starting with this action.\n    return scheduler.flush(this);\n  }\n}\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay: number = 0): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    if (!scheduler.actions.some((action) => action.id === id)) {\n      animationFrameProvider.cancelAnimationFrame(id);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The the difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return true;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass((_super) => function EmptyErrorImpl(this: any) {\n  _super(this);\n  this.name = 'EmptyError';\n  this.message = 'no elements in sequence';\n});\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n *\n * @class NotFoundError\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n","import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n *\n * @class SequenceError\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n","import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time get get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n"],"names":["Symbol_observable","higherOrderRefCount"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}