import * as i2 from 'interacto';
import { InteractionBase, TransitionBase, FSMImpl, BindingsImpl, UpdateBinder, BindingImpl, Undo, Redo, UndoNTimes, RedoNTimes, FocusHTMLElement, UndoHistoryImpl, TreeUndoHistoryImpl, Bindings, UndoHistory, TreeUndoHistory, BindingsContext } from 'interacto';
import * as i3 from '@angular/material/select';
import { MatSelect, MatSelectChange } from '@angular/material/select';
import { MatButtonToggle } from '@angular/material/button-toggle';
import * as i0 from '@angular/core';
import { ElementRef, Directive, Input, Component, ViewChild, Optional, EventEmitter, Host, Output, ChangeDetectionStrategy, HostBinding, NgModule } from '@angular/core';
import * as i2$1 from '@angular/common';
import { CommonModule } from '@angular/common';

class MatEvent extends Event {
    constructor(change) {
        super("material");
        this.change = change;
    }
}
class MatChangeImpl {
    constructor() {
    }
    get change() {
        return this._change;
    }
    flush() {
        this._change = undefined;
    }
}

class MatInteractionBase extends InteractionBase {
    constructor(logger, fsm, data) {
        super(fsm, data, logger);
    }
    registerEventToMatObject(node) {
        if (node instanceof MatSelect) {
            if (this.currentSubscription === undefined) {
                this.currentSubscription = node.selectionChange.subscribe(value => {
                    this.processEvent(new MatEvent(value));
                });
            }
        }
    }
    unregisterEventToMatObject() {
        this.currentSubscription?.unsubscribe();
    }
    onNewNodeRegistered(node) {
        this.getEventTypesOf(this._fsm.currentState).forEach(type => {
            if (node instanceof MatSelect || node instanceof MatButtonToggle) {
                this.registerEventToMatObject(node);
            }
            if (node instanceof EventTarget) {
                this.registerEventToNode(type, node);
                return;
            }
        });
    }
    onNodeUnregistered(node) {
        this.getEventTypesOf(this._fsm.currentState).forEach(type => {
            if (node instanceof EventTarget) {
                this.unregisterEventToNode(type, node);
                return;
            }
            else {
                this.unregisterEventToMatObject();
            }
        });
    }
    reinit() {
        this.unregisterEventToMatObject();
        super.reinit();
    }
    ;
}

class MatSelectChangeTransition extends TransitionBase {
    constructor(srcState, tgtState, action, guard) {
        super(srcState, tgtState, action, guard);
    }
    accept(event) {
        return event instanceof MatEvent && event.change instanceof MatSelectChange;
    }
    getAcceptedEvents() {
        //FIXME: remove as
        return ["material"];
    }
}

class MatSelectFSM extends FSMImpl {
    constructor(logger, dataHandler) {
        super(logger, dataHandler);
        new MatSelectChangeTransition(this.initState, this.addTerminalState("changed"), (evt) => {
            this.dataHandler?.selectionChanged(evt.change);
        });
    }
}
class MatSelectInteraction extends MatInteractionBase {
    constructor(logger) {
        const handler = {
            "selectionChanged": (event) => {
                this._data._change = event;
            },
            "reinitData": () => {
                this.reinitData();
            }
        };
        super(logger, new MatSelectFSM(logger, handler), new MatChangeImpl());
    }
}

/**
 * The Angular and Angular Material extension of Bindings.
 */
class AngularBindings extends BindingsImpl {
    matSelectBinder() {
        return new UpdateBinder(this.undoHistory, this.logger, this.observer)
            .usingInteraction(() => new MatSelectInteraction(this.logger));
    }
}

/**
 * Base class for Interacto's interactions Directives
 * @typeParam T - The type of the HTML element on which the directive operate
 * @typeParam B - The type of the partial binder the directive will produce
 */
class InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef) {
        this.onDyn = onDyn;
        this.element = element;
        this.viewContainerRef = viewContainerRef;
        this.changeDetectorRef = changeDetectorRef;
        this.inputSet = false;
    }
    // tslint:disable-next-line:ban-types
    checkFnName(fn) {
        if (fn === undefined || typeof fn === "string") {
            return undefined;
        }
        return fn?.name;
    }
    callBinder(fn) {
        const fnName = this.checkFnName(fn);
        if (fnName === undefined) {
            return;
        }
        this.inputSet = true;
        // Detects changes to the component and retrieves the input values
        this.changeDetectorRef?.detectChanges();
        const binding = this.getComponent(fnName)[fnName](this.completePartialBinder(), this.getElementContent());
        if (binding instanceof BindingImpl) {
            this.binding = [binding];
        }
        else {
            if (Array.isArray(binding)) {
                this.binding = binding.filter(b => b instanceof BindingImpl).map(b => b);
            }
        }
    }
    getElementContent() {
        return this.element instanceof ElementRef ? this.element.nativeElement : this.element;
    }
    /**
     * Finds the host component. Hack...
     * @param fnName The name of the function to call for building the binding
     */
    getComponent(fnName) {
        // Finding the component. Warning: #horriblehack
        // https://github.com/angular/angular/issues/8277
        // Do not know why '8' (found by inspecting the object at run time)
        return this.viewContainerRef._hostLView[8][fnName] === undefined ?
            // When the directive is used on a template (eg ng For), have to go deeper in the object
            this.viewContainerRef._hostLView[16][8] :
            this.viewContainerRef._hostLView[8];
    }
    ngAfterContentInit() {
        if (!this.inputSet) {
            this.getOutputEvent()?.emit(this.completePartialBinder());
        }
    }
    ngOnDestroy() {
        this.binding?.forEach(b => b.uninstallBinding());
        this.getOutputEvent()?.complete();
    }
    completePartialBinder() {
        const elt = this.getElementContent();
        return (this.onDyn && elt instanceof Node ?
            this.createPartialBinder().onDynamic(elt) :
            this.createPartialBinder().on(this.element));
    }
}
InteractoBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: InteractoBinderDirective, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
InteractoBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: InteractoBinderDirective, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: InteractoBinderDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: undefined }, { type: undefined }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }]; } });

class UndoBinderDirective extends InteractoBinderDirective {
    constructor(element, viewContainerRef, bindings) {
        super(undefined, element, viewContainerRef);
        this.bindings = bindings;
        this.undoObs = bindings.undoHistory
            .undosObservable()
            .subscribe(_ => {
            this.updateUndo();
        });
    }
    set ioUndo(fn) {
        this.callBinder(fn);
    }
    updateUndo() {
        const elt = this.getElementContent();
        elt.disabled = this.bindings.undoHistory.getLastUndo() === undefined;
        elt.title = this.bindings.undoHistory.getLastOrEmptyUndoMessage();
    }
    ngAfterContentInit() {
        this.updateUndo();
        if (!this.inputSet) {
            const b = this.createPartialBinder()
                .catch(err => {
                console.log(err);
            })
                .bind();
            this.binding = [b];
        }
    }
    createPartialBinder() {
        return this.bindings
            .buttonBinder()
            .on(this.element)
            .toProduce(() => new Undo(this.bindings.undoHistory));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.undoObs.unsubscribe();
    }
    getOutputEvent() {
        return undefined;
    }
}
UndoBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: UndoBinderDirective, deps: [{ token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
UndoBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: UndoBinderDirective, selector: "button:ioUndo,button:[ioUndo]", inputs: { ioUndo: "ioUndo" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: UndoBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button:ioUndo,button:[ioUndo]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { ioUndo: [{
                type: Input
            }] } });

class RedoBinderDirective extends InteractoBinderDirective {
    constructor(element, viewContainerRef, bindings) {
        super(undefined, element, viewContainerRef);
        this.bindings = bindings;
        this.redoObs = bindings.undoHistory
            .redosObservable()
            .subscribe(_ => {
            this.updateRedo();
        });
    }
    set ioRedo(fn) {
        this.callBinder(fn);
    }
    updateRedo() {
        const elt = this.getElementContent();
        elt.disabled = this.bindings.undoHistory.getLastRedo() === undefined;
        elt.title = this.bindings.undoHistory.getLastOrEmptyRedoMessage();
    }
    ngAfterContentInit() {
        this.updateRedo();
        if (!this.inputSet) {
            const b = this.createPartialBinder()
                .catch(err => {
                console.log(err);
            })
                .bind();
            this.binding = [b];
        }
    }
    createPartialBinder() {
        return this.bindings
            .buttonBinder()
            .on(this.element)
            .toProduce(() => new Redo(this.bindings.undoHistory));
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.redoObs.unsubscribe();
    }
    getOutputEvent() {
        return undefined;
    }
}
RedoBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: RedoBinderDirective, deps: [{ token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
RedoBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: RedoBinderDirective, selector: "button:ioRedo,button:[ioRedo]", inputs: { ioRedo: "ioRedo" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: RedoBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button:ioRedo,button:[ioRedo]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { ioRedo: [{
                type: Input
            }] } });

class LinearHistoryComponent {
    constructor(undoHistory, bindings) {
        this.undoHistory = undoHistory;
        this.bindings = bindings;
        this.svgViewportWidth = 50;
        this.svgViewportHeight = 50;
        this.svgIconSize = 50;
    }
    ngAfterViewInit() {
        this.bindings.buttonBinder()
            .onDynamic(this.undoButtonContainer)
            .toProduce(i => new UndoNTimes(this.undoHistory, parseInt(i.widget?.getAttribute("data-index") ?? "-1", 0)))
            .bind();
        this.bindings.buttonBinder()
            .onDynamic(this.redoButtonContainer)
            .toProduce(i => new RedoNTimes(this.undoHistory, parseInt(i.widget?.getAttribute("data-index") ?? "-1", 0)))
            .bind();
    }
    undoButtonSnapshot(command, button) {
        const snapshot = command.getVisualSnapshot();
        if (snapshot === undefined) {
            return command.getUndoName();
        }
        if (typeof snapshot === 'string') {
            return `${command.getUndoName()}: ${snapshot}`;
        }
        if (snapshot instanceof SVGElement) {
            button.querySelectorAll('div')[0]?.remove();
            const size = `${this.svgIconSize}px`;
            const div = document.createElement("div");
            div.appendChild(snapshot);
            div.style.width = size;
            div.style.height = size;
            snapshot.setAttribute("viewBox", `0 0 ${this.svgViewportWidth} ${this.svgViewportHeight}`);
            snapshot.setAttribute("width", size);
            snapshot.setAttribute("height", size);
            button.querySelectorAll('div')[0]?.remove();
            button.appendChild(div);
            return command.getUndoName();
        }
        return command.getUndoName();
    }
}
LinearHistoryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: LinearHistoryComponent, deps: [{ token: i2.UndoHistory }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Component });
LinearHistoryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.4", type: LinearHistoryComponent, selector: "io-linear-history", inputs: { svgViewportWidth: "svgViewportWidth", svgViewportHeight: "svgViewportHeight", svgIconSize: "svgIconSize" }, viewQueries: [{ propertyName: "undoButtonContainer", first: true, predicate: ["undoButtonContainer"], descendants: true }, { propertyName: "redoButtonContainer", first: true, predicate: ["redoButtonContainer"], descendants: true }], ngImport: i0, template: "\n<div class=\"header\">\n  <h2>HISTORY</h2>\n  <button ioUndo class=\"button-undo-redo\">UNDO</button>\n  <button ioRedo class=\"button-undo-redo\">REDO</button>\n</div>\n\n<div class=\"buttons\">\n  <div #undoButtonContainer>\n    <button #b *ngFor=\"let undoable of undoHistory.getUndo(); index as i\"\n            class=\"history-button-active\" [attr.data-index]=\"undoHistory.getUndo().length - i\">\n      {{undoButtonSnapshot(undoable, b)}}\n    </button>\n    <br/>\n  </div>\n\n  <div #redoButtonContainer>\n    <p *ngIf=\"undoHistory.getRedo().length > 0\">Redo:</p>\n    <button #b *ngFor=\"let _ of undoHistory.getRedo(); index as i\"\n            class=\"history-button-inactive\" [attr.data-index]=\"i + 1\">\n      {{undoButtonSnapshot(undoHistory.getRedo()[undoHistory.getRedo().length - i - 1], b)}}\n    </button>\n    <br/>\n  </div>\n</div>\n", styles: [".header{background-color:#000;min-height:75px;border-bottom-style:solid}.header h2{font-size:25px;text-align:center;padding-top:25px;padding-bottom:25px;margin:0;color:#fff}.button-undo-redo{width:50%;min-height:40px;border-right-style:solid;border-left-style:solid;color:#000;background-color:#fff;border-width:thin;font-size:20px}.history-button-active{width:100%;border-right-style:none;border-left-style:none;color:#000;background-color:#fff;border-width:thin}.history-button-inactive{width:100%;border-right-style:none;border-left-style:none;color:#d3d3d3;background-color:gray;border-width:thin}.header button:disabled{width:50%;border-right-style:solid;border-left-style:solid;color:#000;background-color:#d3d3d3;border-width:thin;font-size:20px}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: UndoBinderDirective, selector: "button:ioUndo,button:[ioUndo]", inputs: ["ioUndo"] }, { kind: "directive", type: RedoBinderDirective, selector: "button:ioRedo,button:[ioRedo]", inputs: ["ioRedo"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: LinearHistoryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'io-linear-history', template: "\n<div class=\"header\">\n  <h2>HISTORY</h2>\n  <button ioUndo class=\"button-undo-redo\">UNDO</button>\n  <button ioRedo class=\"button-undo-redo\">REDO</button>\n</div>\n\n<div class=\"buttons\">\n  <div #undoButtonContainer>\n    <button #b *ngFor=\"let undoable of undoHistory.getUndo(); index as i\"\n            class=\"history-button-active\" [attr.data-index]=\"undoHistory.getUndo().length - i\">\n      {{undoButtonSnapshot(undoable, b)}}\n    </button>\n    <br/>\n  </div>\n\n  <div #redoButtonContainer>\n    <p *ngIf=\"undoHistory.getRedo().length > 0\">Redo:</p>\n    <button #b *ngFor=\"let _ of undoHistory.getRedo(); index as i\"\n            class=\"history-button-inactive\" [attr.data-index]=\"i + 1\">\n      {{undoButtonSnapshot(undoHistory.getRedo()[undoHistory.getRedo().length - i - 1], b)}}\n    </button>\n    <br/>\n  </div>\n</div>\n", styles: [".header{background-color:#000;min-height:75px;border-bottom-style:solid}.header h2{font-size:25px;text-align:center;padding-top:25px;padding-bottom:25px;margin:0;color:#fff}.button-undo-redo{width:50%;min-height:40px;border-right-style:solid;border-left-style:solid;color:#000;background-color:#fff;border-width:thin;font-size:20px}.history-button-active{width:100%;border-right-style:none;border-left-style:none;color:#000;background-color:#fff;border-width:thin}.history-button-inactive{width:100%;border-right-style:none;border-left-style:none;color:#d3d3d3;background-color:gray;border-width:thin}.header button:disabled{width:50%;border-right-style:solid;border-left-style:solid;color:#000;background-color:#d3d3d3;border-width:thin;font-size:20px}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.UndoHistory }, { type: i2.Bindings }]; }, propDecorators: { undoButtonContainer: [{
                type: ViewChild,
                args: ['undoButtonContainer']
            }], redoButtonContainer: [{
                type: ViewChild,
                args: ['redoButtonContainer']
            }], svgViewportWidth: [{
                type: Input
            }, {
                type: Optional
            }], svgViewportHeight: [{
                type: Input
            }, {
                type: Optional
            }], svgIconSize: [{
                type: Input
            }, {
                type: Optional
            }] } });

class OnDynamicDirective {
}
OnDynamicDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: OnDynamicDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
OnDynamicDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: OnDynamicDirective, selector: "[ioOnDynamic]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: OnDynamicDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioOnDynamic]'
                }]
        }] });

class ClickBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.clickBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the click interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioClick(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.clickBinder();
    }
    getOutputEvent() {
        return this.clickBinder;
    }
}
ClickBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: ClickBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
ClickBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: ClickBinderDirective, selector: "[ioClick]", inputs: { ioClick: "ioClick" }, outputs: { clickBinder: "clickBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: ClickBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioClick]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { clickBinder: [{
                type: Output
            }], ioClick: [{
                type: Input
            }] } });

/**
 * The Angular component for display a tree-based undo/redo history
 */
class TreeHistoryComponent {
    constructor(history, changeDetect) {
        this.history = history;
        this.changeDetect = changeDetect;
        this.svgViewportWidth = 50;
        this.svgViewportHeight = 50;
        this.svgIconSize = 50;
        this.rootRenderer = undefined;
        this.widthcss = "";
        this.cache = {};
        // Only updating the view on history changes
        this.subscriptionUndos = history.undosObservable().subscribe(() => {
            changeDetect.detectChanges();
        });
        this.subscriptionRedos = history.redosObservable().subscribe(() => {
            changeDetect.detectChanges();
        });
    }
    ngAfterViewInit() {
        // Preventing the input attributes to update the view
        this.changeDetect.detach();
    }
    ngOnDestroy() {
        this.subscriptionUndos.unsubscribe();
        this.subscriptionRedos.unsubscribe();
    }
    depth(undoableNode) {
        let depth = -1;
        let n = undoableNode;
        while (n !== undefined) {
            depth++;
            n = n.parent;
        }
        return Math.max(0, depth);
    }
    createHtmlTag(snapshot, div, svg) {
        div.querySelectorAll('div')[0]?.remove();
        const size = `${this.svgIconSize}px`;
        const divpic = document.createElement("div");
        divpic.appendChild(snapshot);
        divpic.style.width = size;
        divpic.style.height = size;
        if (svg) {
            snapshot.setAttribute("viewBox", `0 0 ${this.svgViewportWidth} ${this.svgViewportHeight}`);
        }
        snapshot.setAttribute("width", size);
        snapshot.setAttribute("height", size);
        div.appendChild(divpic);
    }
    undoButtonSnapshot_(snapshot, txt, div) {
        if (typeof snapshot === 'string') {
            return `${txt}: ${snapshot}`;
        }
        if (snapshot instanceof SVGElement) {
            this.createHtmlTag(snapshot, div, true);
            return txt;
        }
        if (snapshot instanceof HTMLElement) {
            this.createHtmlTag(snapshot, div, false);
            return undefined;
        }
        return txt;
    }
    undoButtonSnapshot(node, div) {
        if (node === undefined) {
            if (this.cacheRoot === undefined) {
                this.cacheRoot = this.rootRenderer;
            }
        }
        else {
            if (this.cache[node.id] === undefined) {
                this.cache[node.id] = node.visualSnapshot;
            }
        }
        const snapshot = node === undefined ? this.cacheRoot : this.cache[node.id];
        const txt = node === undefined ? "Root" : node.undoable.getUndoName();
        if (snapshot === undefined) {
            return txt;
        }
        if (snapshot instanceof Promise) {
            void snapshot.then((res) => {
                if (node !== undefined) {
                    this.cache[node.id] = res;
                }
                else {
                    this.cacheRoot = res;
                }
                return this.undoButtonSnapshot_(res, txt, div);
            });
            return txt;
        }
        if (node?.id === this.history.currentNode.id) {
            div.scrollIntoView();
        }
        return this.undoButtonSnapshot_(snapshot, txt, div);
    }
    clickBinders(binder, position) {
        return [
            binder
                .toProduceAnon(() => {
                this.history.goTo(position);
            })
                .when(i => i.button === 0)
                .bind(),
            binder
                .toProduceAnon(() => {
                this.history.delete(position);
            })
                .when(i => !this.history.keepPath && i.button === 2)
                .ifHadEffects(() => {
                this.changeDetect.detectChanges();
            })
                .bind()
        ];
    }
    getTop(position) {
        return this.depth(this.history.undoableNodes[position.key]) * (this.svgIconSize + 10) + 10;
    }
    getLeft(position) {
        return position.value * (this.svgIconSize + 10) + 10;
    }
}
TreeHistoryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TreeHistoryComponent, deps: [{ token: i2.TreeUndoHistory }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
TreeHistoryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.4", type: TreeHistoryComponent, selector: "io-tree-history", inputs: { width: "width", svgViewportWidth: "svgViewportWidth", svgViewportHeight: "svgViewportHeight", svgIconSize: "svgIconSize", rootRenderer: "rootRenderer" }, host: { properties: { "style.width": "this.widthcss" } }, ngImport: i0, template: "<div class=\"header\">\n  <h2>HISTORY</h2>\n  <button ioUndo class=\"button-undo-redo\">undo</button>\n  <button ioRedo class=\"button-undo-redo\">redo</button>\n</div>\n\n<div class=\"tree\" oncontextmenu=\"return false;\">\n  <div #d class=\"tree-node-history\" *ngFor=\"let position of history.getPositions() | keyvalue\"\n       [ngStyle]=\"{left: getLeft(position) + 'px', top: getTop(position) + 'px'}\"\n       [ngClass]=\"history.currentNode.id === position.key ? 'current-node' : ''\"\n       [ioClick] (clickBinder)=\"clickBinders($event, position.key)\">\n    {{undoButtonSnapshot(history.undoableNodes[position.key], d)}}\n  </div>\n</div>\n", styles: [".header{background-color:#000;min-height:75px;border-bottom-style:solid}.header h2{font-size:25px;text-align:center;padding-top:25px;padding-bottom:25px;margin:0;color:#fff}.tree-node-history{position:absolute;padding:0;border-style:solid;color:#000;background-color:#fff;border-width:thin;-webkit-user-select:none;user-select:none}.button-undo-redo{width:50%;min-height:40px;border-right-style:solid;border-left-style:solid;color:#000;background-color:#fff;border-width:thin;font-size:20px}.header button:disabled{width:50%;border-right-style:solid;border-left-style:solid;color:#000;background-color:#d3d3d3;border-width:thin;font-size:20px}.current-node{background-color:#708090}.tree{overflow:auto;width:inherit;height:inherit;position:fixed}\n"], dependencies: [{ kind: "directive", type: i2$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: ClickBinderDirective, selector: "[ioClick]", inputs: ["ioClick"], outputs: ["clickBinder"] }, { kind: "directive", type: UndoBinderDirective, selector: "button:ioUndo,button:[ioUndo]", inputs: ["ioUndo"] }, { kind: "directive", type: RedoBinderDirective, selector: "button:ioRedo,button:[ioRedo]", inputs: ["ioRedo"] }, { kind: "pipe", type: i2$1.KeyValuePipe, name: "keyvalue" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TreeHistoryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'io-tree-history', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"header\">\n  <h2>HISTORY</h2>\n  <button ioUndo class=\"button-undo-redo\">undo</button>\n  <button ioRedo class=\"button-undo-redo\">redo</button>\n</div>\n\n<div class=\"tree\" oncontextmenu=\"return false;\">\n  <div #d class=\"tree-node-history\" *ngFor=\"let position of history.getPositions() | keyvalue\"\n       [ngStyle]=\"{left: getLeft(position) + 'px', top: getTop(position) + 'px'}\"\n       [ngClass]=\"history.currentNode.id === position.key ? 'current-node' : ''\"\n       [ioClick] (clickBinder)=\"clickBinders($event, position.key)\">\n    {{undoButtonSnapshot(history.undoableNodes[position.key], d)}}\n  </div>\n</div>\n", styles: [".header{background-color:#000;min-height:75px;border-bottom-style:solid}.header h2{font-size:25px;text-align:center;padding-top:25px;padding-bottom:25px;margin:0;color:#fff}.tree-node-history{position:absolute;padding:0;border-style:solid;color:#000;background-color:#fff;border-width:thin;-webkit-user-select:none;user-select:none}.button-undo-redo{width:50%;min-height:40px;border-right-style:solid;border-left-style:solid;color:#000;background-color:#fff;border-width:thin;font-size:20px}.header button:disabled{width:50%;border-right-style:solid;border-left-style:solid;color:#000;background-color:#d3d3d3;border-width:thin;font-size:20px}.current-node{background-color:#708090}.tree{overflow:auto;width:inherit;height:inherit;position:fixed}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.TreeUndoHistory }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { width: [{
                type: Input
            }], svgViewportWidth: [{
                type: Input
            }], svgViewportHeight: [{
                type: Input
            }], svgIconSize: [{
                type: Input
            }], rootRenderer: [{
                type: Input
            }], widthcss: [{
                type: HostBinding,
                args: ['style.width']
            }] } });

class AnchorBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.aBinder = new EventEmitter();
    }
    set ioAnchor(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.hyperlinkBinder();
    }
    getOutputEvent() {
        return this.aBinder;
    }
}
AnchorBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: AnchorBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
AnchorBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: AnchorBinderDirective, selector: "a:[ioAnchor],[ioAnchor] [ioOnDynamic]", inputs: { ioAnchor: "ioAnchor" }, outputs: { aBinder: "aBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: AnchorBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'a:[ioAnchor],[ioAnchor] [ioOnDynamic]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { aBinder: [{
                type: Output
            }], ioAnchor: [{
                type: Input
            }] } });

class ButtonBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.buttonBinder = new EventEmitter();
    }
    set ioButton(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.buttonBinder();
    }
    getOutputEvent() {
        return this.buttonBinder;
    }
}
ButtonBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: ButtonBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
ButtonBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: ButtonBinderDirective, selector: "button:[ioButton],[ioButton] [ioOnDynamic]", inputs: { ioButton: "ioButton" }, outputs: { buttonBinder: "buttonBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: ButtonBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button:[ioButton],[ioButton] [ioOnDynamic]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { buttonBinder: [{
                type: Output
            }], ioButton: [{
                type: Input
            }] } });

class ClicksBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * The expected number of clicks.
         */
        this.count = 2;
        this.clicksBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the clicks interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioClicks(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        let countValue = typeof this.count === 'number' ? this.count : parseInt(this.count, 0);
        if (isNaN(countValue)) {
            console.log('Cannot create a clicks binder since the value of number is ' +
                'not a number (in string or number format). So using the default value: 2');
            countValue = 2;
        }
        return this.bindings.clicksBinder(countValue);
    }
    getOutputEvent() {
        return this.clicksBinder;
    }
}
ClicksBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: ClicksBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
ClicksBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: ClicksBinderDirective, selector: "[ioClicks]", inputs: { count: "count", ioClicks: "ioClicks" }, outputs: { clicksBinder: "clicksBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: ClicksBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioClicks]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { clicksBinder: [{
                type: Output
            }], count: [{
                type: Input
            }], ioClicks: [{
                type: Input
            }] } });

class DoubleClickBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.dbleclickBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the double-click interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioDoubleClick(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.dbleClickBinder();
    }
    getOutputEvent() {
        return this.dbleclickBinder;
    }
}
DoubleClickBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: DoubleClickBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
DoubleClickBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: DoubleClickBinderDirective, selector: "[ioDoubleClick]", inputs: { ioDoubleClick: "ioDoubleClick" }, outputs: { dbleclickBinder: "dbleclickBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: DoubleClickBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioDoubleClick]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { dbleclickBinder: [{
                type: Output
            }], ioDoubleClick: [{
                type: Input
            }] } });

class DndBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        this.cancellable = true;
        this.dndBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the key pressure interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioDnd(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.dndBinder(this.cancellable);
    }
    getOutputEvent() {
        return this.dndBinder;
    }
}
DndBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: DndBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
DndBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: DndBinderDirective, selector: "[ioDnd]", inputs: { cancellable: "cancellable", ioDnd: "ioDnd" }, outputs: { dndBinder: "dndBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: DndBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioDnd]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { dndBinder: [{
                type: Output
            }], cancellable: [{
                type: Input
            }], ioDnd: [{
                type: Input
            }] } });

class DragLockBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.dragLockBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the drag lock interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioDragLock(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.dragLockBinder();
    }
    getOutputEvent() {
        return this.dragLockBinder;
    }
}
DragLockBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: DragLockBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
DragLockBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: DragLockBinderDirective, selector: "[ioDragLock]", inputs: { ioDragLock: "ioDragLock" }, outputs: { dragLockBinder: "dragLockBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: DragLockBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioDragLock]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { dragLockBinder: [{
                type: Output
            }], ioDragLock: [{
                type: Input
            }] } });

class FocusOnMouseEnterDirective {
    constructor(element, bindings) {
        this.element = element;
        this.bindings = bindings;
    }
    ngAfterContentInit() {
        this.binding = this.bindings
            .mouseEnterBinder(true)
            .on(this.element)
            .toProduce(i => new FocusHTMLElement(i.currentTarget))
            .bind();
    }
    ngOnDestroy() {
        if (this.binding !== undefined) {
            this.binding.uninstallBinding();
        }
    }
}
FocusOnMouseEnterDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: FocusOnMouseEnterDirective, deps: [{ token: i0.ElementRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
FocusOnMouseEnterDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: FocusOnMouseEnterDirective, selector: "[ioFocusOnMouseEnter]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: FocusOnMouseEnterDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioFocusOnMouseEnter]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i2.Bindings }]; } });

class InputBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.inputBinder = new EventEmitter();
    }
    set ioInput(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        const elt = this.getElementContent();
        if (elt instanceof HTMLInputElement) {
            switch (elt.type) {
                case 'checkbox':
                case 'radio':
                    return this.bindings.checkboxBinder();
                case 'color':
                    return this.bindings.colorPickerBinder();
                case 'date':
                    return this.bindings.dateBinder();
                case 'number':
                    return this.bindings.spinnerBinder();
            }
        }
        throw new Error('Cannot create a binder on the input.');
    }
    getOutputEvent() {
        return this.inputBinder;
    }
}
InputBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: InputBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
InputBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: InputBinderDirective, selector: "input:[ioInput] :not([type=text]), [ioInput] [ioOnDynamic]", inputs: { ioInput: "ioInput" }, outputs: { inputBinder: "inputBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: InputBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input:[ioInput] :not([type=text]), [ioInput] [ioOnDynamic]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { inputBinder: [{
                type: Output
            }], ioInput: [{
                type: Input
            }] } });

class KeydownBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        this.modifierAccepted = true;
        this.keydownBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the key pressure interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioKeydown(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.keyDownBinder(this.modifierAccepted);
    }
    getOutputEvent() {
        return this.keydownBinder;
    }
}
KeydownBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeydownBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
KeydownBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: KeydownBinderDirective, selector: "[ioKeydown]", inputs: { modifierAccepted: "modifierAccepted", ioKeydown: "ioKeydown" }, outputs: { keydownBinder: "keydownBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeydownBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioKeydown]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { keydownBinder: [{
                type: Output
            }], modifierAccepted: [{
                type: Input
            }], ioKeydown: [{
                type: Input
            }] } });

class KeyupBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        this.modifierAccepted = true;
        this.keyupBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the key pressure interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioKeyup(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.keyUpBinder(this.modifierAccepted);
    }
    getOutputEvent() {
        return this.keyupBinder;
    }
}
KeyupBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeyupBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
KeyupBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: KeyupBinderDirective, selector: "[ioKeyup]", inputs: { modifierAccepted: "modifierAccepted", ioKeyup: "ioKeyup" }, outputs: { keyupBinder: "keyupBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeyupBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioKeyup]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { keyupBinder: [{
                type: Output
            }], modifierAccepted: [{
                type: Input
            }], ioKeyup: [{
                type: Input
            }] } });

class KeysdownBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.keysdownBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the keys pressed interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioKeysdown(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.keysDownBinder();
    }
    getOutputEvent() {
        return this.keysdownBinder;
    }
}
KeysdownBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeysdownBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
KeysdownBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: KeysdownBinderDirective, selector: "[ioKeysdown]", inputs: { ioKeysdown: "ioKeysdown" }, outputs: { keysdownBinder: "keysdownBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeysdownBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioKeysdown]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { keysdownBinder: [{
                type: Output
            }], ioKeysdown: [{
                type: Input
            }] } });

class KeyTypeBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.keyTypeBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the key typing interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioKeyType(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.keyTypeBinder();
    }
    getOutputEvent() {
        return this.keyTypeBinder;
    }
}
KeyTypeBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeyTypeBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
KeyTypeBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: KeyTypeBinderDirective, selector: "[ioKeyType]", inputs: { ioKeyType: "ioKeyType" }, outputs: { keyTypeBinder: "keyTypeBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeyTypeBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioKeyType]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { keyTypeBinder: [{
                type: Output
            }], ioKeyType: [{
                type: Input
            }] } });

class KeysTypeBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.keysTypeBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the multiple key typing interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioKeysType(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.keysTypeBinder();
    }
    getOutputEvent() {
        return this.keysTypeBinder;
    }
}
KeysTypeBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeysTypeBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
KeysTypeBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: KeysTypeBinderDirective, selector: "[ioKeysType]", inputs: { ioKeysType: "ioKeysType" }, outputs: { keysTypeBinder: "keysTypeBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: KeysTypeBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioKeysType]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { keysTypeBinder: [{
                type: Output
            }], ioKeysType: [{
                type: Input
            }] } });

class LongTouchBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * The duration of the touch to end the user interaction.
         * If this duration is not reached, the interaction is cancelled.
         */
        this.duration = 1000;
        this.longTouchBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the long touch interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioLongTouch(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.longTouchBinder(this.duration);
    }
    getOutputEvent() {
        return this.longTouchBinder;
    }
}
LongTouchBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: LongTouchBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
LongTouchBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: LongTouchBinderDirective, selector: "[ioLongTouch]", inputs: { duration: "duration", ioLongTouch: "ioLongTouch" }, outputs: { longTouchBinder: "longTouchBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: LongTouchBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioLongTouch]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { longTouchBinder: [{
                type: Output
            }], duration: [{
                type: Input
            }], ioLongTouch: [{
                type: Input
            }] } });

class LongMousedownBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * The duration of the pressure to end the user interaction.
         * If this duration is not reached, the interaction is cancelled.
         */
        this.duration = 1000;
        this.longMousedownBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the long press interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioLongMousedown(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.longMouseDownBinder(this.duration);
    }
    getOutputEvent() {
        return this.longMousedownBinder;
    }
}
LongMousedownBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: LongMousedownBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
LongMousedownBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: LongMousedownBinderDirective, selector: "[ioLongMousedown]", inputs: { duration: "duration", ioLongMousedown: "ioLongMousedown" }, outputs: { longMousedownBinder: "longMousedownBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: LongMousedownBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioLongMousedown]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { longMousedownBinder: [{
                type: Output
            }], duration: [{
                type: Input
            }], ioLongMousedown: [{
                type: Input
            }] } });

class MultiTouchBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * The number of required touches.
         * A multi-touch starts when all its touches have started.
         * A multi-touch ends when the number of required touches is greater than the number of touches.
         */
        this.nbTouches = 2;
        this.multiTouchBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the multi touch interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioMultiTouch(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.multiTouchBinder(this.nbTouches);
    }
    getOutputEvent() {
        return this.multiTouchBinder;
    }
}
MultiTouchBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MultiTouchBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
MultiTouchBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: MultiTouchBinderDirective, selector: "[ioMultiTouch]", inputs: { nbTouches: "nbTouches", ioMultiTouch: "ioMultiTouch" }, outputs: { multiTouchBinder: "multiTouchBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MultiTouchBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioMultiTouch]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { multiTouchBinder: [{
                type: Output
            }], nbTouches: [{
                type: Input
            }], ioMultiTouch: [{
                type: Input
            }] } });

class PanBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * Defines whether the pan is horizontal or vertical
         */
        this.horizontal = true;
        /**
         * The minimal distance from the starting point to the release point for validating the pan
         */
        this.minLength = 100;
        /**
         * The tolerance rate in pixels accepted while executing the pan
         */
        this.pxTolerance = 20;
        /**
         * The number of touches required to start the interaction
         */
        this.nbTouches = 1;
        this.panBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the pan interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioPan(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.panBinder(this.horizontal, this.minLength, this.nbTouches, this.pxTolerance);
    }
    getOutputEvent() {
        return this.panBinder;
    }
}
PanBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: PanBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
PanBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: PanBinderDirective, selector: "[ioPan]", inputs: { horizontal: "horizontal", minLength: "minLength", pxTolerance: "pxTolerance", nbTouches: "nbTouches", ioPan: "ioPan" }, outputs: { panBinder: "panBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: PanBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioPan]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { panBinder: [{
                type: Output
            }], horizontal: [{
                type: Input
            }], minLength: [{
                type: Input
            }], pxTolerance: [{
                type: Input
            }], nbTouches: [{
                type: Input
            }], ioPan: [{
                type: Input
            }] } });

class MousedownBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.mousedownBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the mouse press interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioMousedown(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.mouseDownBinder();
    }
    getOutputEvent() {
        return this.mousedownBinder;
    }
}
MousedownBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MousedownBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
MousedownBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: MousedownBinderDirective, selector: "[ioMousedown]", inputs: { ioMousedown: "ioMousedown" }, outputs: { mousedownBinder: "mousedownBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MousedownBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioMousedown]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { mousedownBinder: [{
                type: Output
            }], ioMousedown: [{
                type: Input
            }] } });

class MousemoveBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.mousemoveBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the mouse press interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioMousemove(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.mouseMoveBinder();
    }
    getOutputEvent() {
        return this.mousemoveBinder;
    }
}
MousemoveBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MousemoveBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
MousemoveBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: MousemoveBinderDirective, selector: "[ioMousemove]", inputs: { ioMousemove: "ioMousemove" }, outputs: { mousemoveBinder: "mousemoveBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MousemoveBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioMousemove]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { mousemoveBinder: [{
                type: Output
            }], ioMousemove: [{
                type: Input
            }] } });

class MouseenterBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * The expected number of clicks.
         */
        this.bubbling = false;
        this.mouseenterBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the mouse press interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioMouseenter(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        const withbubbling = typeof this.bubbling === 'boolean' ? this.bubbling : this.bubbling === 'true';
        return this.bindings.mouseEnterBinder(withbubbling);
    }
    getOutputEvent() {
        return this.mouseenterBinder;
    }
}
MouseenterBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MouseenterBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
MouseenterBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: MouseenterBinderDirective, selector: "[ioMouseenter]", inputs: { bubbling: "bubbling", ioMouseenter: "ioMouseenter" }, outputs: { mouseenterBinder: "mouseenterBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MouseenterBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioMouseenter]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { mouseenterBinder: [{
                type: Output
            }], bubbling: [{
                type: Input
            }], ioMouseenter: [{
                type: Input
            }] } });

class MouseleaveBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * The expected number of clicks.
         */
        this.bubbling = false;
        this.mouseleaveBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the mouse press interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioMouseleave(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        const withbubbling = typeof this.bubbling === 'boolean' ? this.bubbling : this.bubbling === 'true';
        return this.bindings.mouseLeaveBinder(withbubbling);
    }
    getOutputEvent() {
        return this.mouseleaveBinder;
    }
}
MouseleaveBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MouseleaveBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
MouseleaveBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: MouseleaveBinderDirective, selector: "[ioMouseleave]", inputs: { bubbling: "bubbling", ioMouseleave: "ioMouseleave" }, outputs: { mouseleaveBinder: "mouseleaveBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MouseleaveBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioMouseleave]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { mouseleaveBinder: [{
                type: Output
            }], bubbling: [{
                type: Input
            }], ioMouseleave: [{
                type: Input
            }] } });

class MouseupBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.mouseupBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the mouse press interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioMouseup(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.mouseUpBinder();
    }
    getOutputEvent() {
        return this.mouseupBinder;
    }
}
MouseupBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MouseupBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
MouseupBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: MouseupBinderDirective, selector: "[ioMouseup]", inputs: { ioMouseup: "ioMouseup" }, outputs: { mouseupBinder: "mouseupBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MouseupBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioMouseup]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { mouseupBinder: [{
                type: Output
            }], ioMouseup: [{
                type: Input
            }] } });

class SelectBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.selectBinder = new EventEmitter();
    }
    set ioSelect(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.comboBoxBinder();
    }
    getOutputEvent() {
        return this.selectBinder;
    }
}
SelectBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: SelectBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
SelectBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: SelectBinderDirective, selector: "select:[ioSelect], [ioSelect] [ioOnDynamic]", inputs: { ioSelect: "ioSelect" }, outputs: { selectBinder: "selectBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: SelectBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'select:[ioSelect], [ioSelect] [ioOnDynamic]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { selectBinder: [{
                type: Output
            }], ioSelect: [{
                type: Input
            }] } });

class SwipeBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * Defines whether the swipe is horizontal or vertical
         */
        this.horizontal = true;
        /**
         * The minimal minVelocity to reach for validating the swipe. In pixels per second.
         */
        this.minVelocity = 100;
        /**
         * The minimal distance from the starting point to the release point for validating the swipe
         */
        this.minLength = 100;
        /**
         * The tolerance rate in pixels accepted while executing the swipe
         */
        this.pxTolerance = 20;
        /**
         * The number of touches required to start the interaction
         */
        this.nbTouches = 1;
        this.swipeBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the swipe interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioSwipe(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.swipeBinder(this.horizontal, this.minVelocity, this.minLength, this.nbTouches, this.pxTolerance);
    }
    getOutputEvent() {
        return this.swipeBinder;
    }
}
SwipeBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: SwipeBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
SwipeBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: SwipeBinderDirective, selector: "[ioSwipe]", inputs: { horizontal: "horizontal", minVelocity: "minVelocity", minLength: "minLength", pxTolerance: "pxTolerance", nbTouches: "nbTouches", ioSwipe: "ioSwipe" }, outputs: { swipeBinder: "swipeBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: SwipeBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioSwipe]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { swipeBinder: [{
                type: Output
            }], horizontal: [{
                type: Input
            }], minVelocity: [{
                type: Input
            }], minLength: [{
                type: Input
            }], pxTolerance: [{
                type: Input
            }], nbTouches: [{
                type: Input
            }], ioSwipe: [{
                type: Input
            }] } });

class TapBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * The number of taps expected to end the interaction.
         * If this number is not reached after a timeout, the interaction is cancelled.
         */
        this.nbTaps = 2;
        this.tapBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the tap interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioTap(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.tapBinder(this.nbTaps);
    }
    getOutputEvent() {
        return this.tapBinder;
    }
}
TapBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TapBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
TapBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: TapBinderDirective, selector: "[ioTap]", inputs: { nbTaps: "nbTaps", ioTap: "ioTap" }, outputs: { tapBinder: "tapBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TapBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioTap]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { tapBinder: [{
                type: Output
            }], nbTaps: [{
                type: Input
            }], ioTap: [{
                type: Input
            }] } });

class TextAreaBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.textareaBinder = new EventEmitter();
    }
    set ioTextarea(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.textInputBinder();
    }
    getOutputEvent() {
        return this.textareaBinder;
    }
}
TextAreaBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TextAreaBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
TextAreaBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: TextAreaBinderDirective, selector: "textarea:[ioTextarea], [ioTextarea] [ioOnDynamic]", inputs: { ioTextarea: "ioTextarea" }, outputs: { textareaBinder: "textareaBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TextAreaBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'textarea:[ioTextarea], [ioTextarea] [ioOnDynamic]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { textareaBinder: [{
                type: Output
            }], ioTextarea: [{
                type: Input
            }] } });

class TextInputBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, bindings) {
        super(onDyn, element, viewContainerRef);
        this.bindings = bindings;
        this.textinputBinder = new EventEmitter();
    }
    set ioTextinput(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.textInputBinder();
    }
    getOutputEvent() {
        return this.textinputBinder;
    }
}
TextInputBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TextInputBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
TextInputBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: TextInputBinderDirective, selector: "input:[ioTextinput][type=text], [ioTextinput] [ioOnDynamic]", inputs: { ioTextinput: "ioTextinput" }, outputs: { textinputBinder: "textinputBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TextInputBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input:[ioTextinput][type=text], [ioTextinput] [ioOnDynamic]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.Bindings }]; }, propDecorators: { textinputBinder: [{
                type: Output
            }], ioTextinput: [{
                type: Input
            }] } });

class MatSelectBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, 
    // element: ElementRef<HTMLElement>,
    viewContainerRef, bindings, 
    // The MatSelect component
    select) {
        super(onDyn, select, viewContainerRef);
        this.bindings = bindings;
        this.matSelectBinder = new EventEmitter();
    }
    set ioMatSelect(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.matSelectBinder();
    }
    getOutputEvent() {
        return this.matSelectBinder;
    }
}
MatSelectBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MatSelectBinderDirective, deps: [{ token: OnDynamicDirective, host: true, optional: true }, { token: i0.ViewContainerRef }, { token: AngularBindings }, { token: i3.MatSelect }], target: i0.ɵɵFactoryTarget.Directive });
MatSelectBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: MatSelectBinderDirective, selector: "mat-select:[ioMatSelect],[ioMatSelect] [ioOnDynamic]", inputs: { ioMatSelect: "ioMatSelect" }, outputs: { matSelectBinder: "matSelectBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: MatSelectBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'mat-select:[ioMatSelect],[ioMatSelect] [ioOnDynamic]'
                }]
        }], ctorParameters: function () { return [{ type: OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ViewContainerRef }, { type: AngularBindings }, { type: i3.MatSelect }]; }, propDecorators: { matSelectBinder: [{
                type: Output
            }], ioMatSelect: [{
                type: Input
            }] } });

/**
 * Provides an undo history of the provided Bindings object
 * @param ctx The bindings object that contains the history
 * @typeParam T -- The type of the undo history
 */
function undoHistoryFactory(ctx) {
    return ctx.undoHistory;
}
/**
 * Provides a Bindings object that uses a standard linear undo history
 */
function bindingsLinearUndoHistoryFactory() {
    return new AngularBindings(new UndoHistoryImpl());
}
/**
 * Provides a Bindings object that uses a standard linear undo history
 */
function bindingsTreeUndoHistoryFactory(keepHistoryTraces) {
    return new AngularBindings(new TreeUndoHistoryImpl(keepHistoryTraces));
}
/**
 * Provides dependency injection for Interacto.
 * Useful for injecting a specific bindings and undo history to an Angular component.
 * This injection will use a classical linear undo history. For other kinds of undo algorithm, see
 * the other providers.
 * This undo algorithm is the default one Interacto uses.
 */
function interactoProviders() {
    return [
        { provide: AngularBindings, useFactory: bindingsLinearUndoHistoryFactory },
        { provide: Bindings, useExisting: AngularBindings },
        { provide: UndoHistory, useFactory: undoHistoryFactory, deps: [AngularBindings] }
    ];
}
/**
 * Provides dependency injection for Interacto.
 * Useful for injecting a specific bindings and undo history to an Angular component.
 * This injection will use a tree undo history. For other kinds of undo algorithm, see
 * the other providers.
 * @param keepHistoryTraces - States whether the history will keep in memory the ordered
 * sequence of commands the users performed. This allows to keep traces about the design process.
 * If set to true, users would not be able to delete history elements.
 */
function interactoTreeUndoProviders(keepHistoryTraces = false) {
    return [
        { provide: AngularBindings, useFactory: () => bindingsTreeUndoHistoryFactory(keepHistoryTraces) },
        { provide: Bindings, useExisting: AngularBindings },
        { provide: TreeUndoHistory, useFactory: undoHistoryFactory, deps: [AngularBindings] }
    ];
}
class InteractoModule {
}
InteractoModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: InteractoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
InteractoModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.0.4", ngImport: i0, type: InteractoModule, declarations: [LinearHistoryComponent,
        TreeHistoryComponent,
        ClicksBinderDirective,
        ClickBinderDirective,
        DoubleClickBinderDirective,
        UndoBinderDirective,
        RedoBinderDirective,
        DragLockBinderDirective,
        KeydownBinderDirective,
        KeyupBinderDirective,
        KeysdownBinderDirective,
        KeyTypeBinderDirective,
        KeysTypeBinderDirective,
        DndBinderDirective,
        LongMousedownBinderDirective,
        LongTouchBinderDirective,
        MultiTouchBinderDirective,
        PanBinderDirective,
        MousedownBinderDirective,
        MousemoveBinderDirective,
        MouseenterBinderDirective,
        MouseleaveBinderDirective,
        MouseupBinderDirective,
        SwipeBinderDirective,
        TapBinderDirective,
        TextAreaBinderDirective,
        TextInputBinderDirective,
        ButtonBinderDirective,
        InputBinderDirective,
        SelectBinderDirective,
        AnchorBinderDirective,
        MatSelectBinderDirective,
        FocusOnMouseEnterDirective,
        OnDynamicDirective], imports: [CommonModule], exports: [LinearHistoryComponent,
        TreeHistoryComponent,
        ClicksBinderDirective,
        ClickBinderDirective,
        DoubleClickBinderDirective,
        UndoBinderDirective,
        RedoBinderDirective,
        DragLockBinderDirective,
        KeydownBinderDirective,
        KeyupBinderDirective,
        KeysdownBinderDirective,
        KeyTypeBinderDirective,
        KeysTypeBinderDirective,
        DndBinderDirective,
        LongMousedownBinderDirective,
        LongTouchBinderDirective,
        MultiTouchBinderDirective,
        PanBinderDirective,
        MousedownBinderDirective,
        MousemoveBinderDirective,
        MouseenterBinderDirective,
        MouseleaveBinderDirective,
        MouseupBinderDirective,
        SwipeBinderDirective,
        TapBinderDirective,
        TextAreaBinderDirective,
        TextInputBinderDirective,
        ButtonBinderDirective,
        InputBinderDirective,
        SelectBinderDirective,
        AnchorBinderDirective,
        MatSelectBinderDirective,
        FocusOnMouseEnterDirective,
        OnDynamicDirective] });
InteractoModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: InteractoModule, providers: [interactoProviders()], imports: [CommonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: InteractoModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        LinearHistoryComponent,
                        TreeHistoryComponent,
                        ClicksBinderDirective,
                        ClickBinderDirective,
                        DoubleClickBinderDirective,
                        UndoBinderDirective,
                        RedoBinderDirective,
                        DragLockBinderDirective,
                        KeydownBinderDirective,
                        KeyupBinderDirective,
                        KeysdownBinderDirective,
                        KeyTypeBinderDirective,
                        KeysTypeBinderDirective,
                        DndBinderDirective,
                        LongMousedownBinderDirective,
                        LongTouchBinderDirective,
                        MultiTouchBinderDirective,
                        PanBinderDirective,
                        MousedownBinderDirective,
                        MousemoveBinderDirective,
                        MouseenterBinderDirective,
                        MouseleaveBinderDirective,
                        MouseupBinderDirective,
                        SwipeBinderDirective,
                        TapBinderDirective,
                        TextAreaBinderDirective,
                        TextInputBinderDirective,
                        ButtonBinderDirective,
                        InputBinderDirective,
                        SelectBinderDirective,
                        AnchorBinderDirective,
                        MatSelectBinderDirective,
                        FocusOnMouseEnterDirective,
                        OnDynamicDirective
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        LinearHistoryComponent,
                        TreeHistoryComponent,
                        ClicksBinderDirective,
                        ClickBinderDirective,
                        DoubleClickBinderDirective,
                        UndoBinderDirective,
                        RedoBinderDirective,
                        DragLockBinderDirective,
                        KeydownBinderDirective,
                        KeyupBinderDirective,
                        KeysdownBinderDirective,
                        KeyTypeBinderDirective,
                        KeysTypeBinderDirective,
                        DndBinderDirective,
                        LongMousedownBinderDirective,
                        LongTouchBinderDirective,
                        MultiTouchBinderDirective,
                        PanBinderDirective,
                        MousedownBinderDirective,
                        MousemoveBinderDirective,
                        MouseenterBinderDirective,
                        MouseleaveBinderDirective,
                        MouseupBinderDirective,
                        SwipeBinderDirective,
                        TapBinderDirective,
                        TextAreaBinderDirective,
                        TextInputBinderDirective,
                        ButtonBinderDirective,
                        InputBinderDirective,
                        SelectBinderDirective,
                        AnchorBinderDirective,
                        MatSelectBinderDirective,
                        FocusOnMouseEnterDirective,
                        OnDynamicDirective
                    ],
                    providers: [interactoProviders()],
                }]
        }] });

function bindingsContextFactory() {
    return new BindingsContext();
}
function testingBindingsFactory(ctx) {
    const binding = new AngularBindings(new UndoHistoryImpl());
    binding.setBindingObserver(ctx);
    return binding;
}
class TestingInteractoModule {
}
TestingInteractoModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TestingInteractoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TestingInteractoModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.0.4", ngImport: i0, type: TestingInteractoModule });
TestingInteractoModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TestingInteractoModule, providers: [{
            provide: BindingsContext,
            useFactory: bindingsContextFactory
        }, {
            provide: AngularBindings,
            useFactory: testingBindingsFactory,
            deps: [
                BindingsContext
            ]
        }, {
            provide: Bindings,
            useExisting: AngularBindings,
        }, {
            provide: UndoHistory,
            useFactory: undoHistoryFactory,
            deps: [
                AngularBindings
            ]
        }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TestingInteractoModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [{
                            provide: BindingsContext,
                            useFactory: bindingsContextFactory
                        }, {
                            provide: AngularBindings,
                            useFactory: testingBindingsFactory,
                            deps: [
                                BindingsContext
                            ]
                        }, {
                            provide: Bindings,
                            useExisting: AngularBindings,
                        }, {
                            provide: UndoHistory,
                            useFactory: undoHistoryFactory,
                            deps: [
                                AngularBindings
                            ]
                        }],
                }]
        }] });

/*
 * Public API Surface of interacto-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AnchorBinderDirective, AngularBindings, ButtonBinderDirective, ClickBinderDirective, ClicksBinderDirective, DndBinderDirective, DoubleClickBinderDirective, DragLockBinderDirective, FocusOnMouseEnterDirective, InputBinderDirective, InteractoModule, KeyTypeBinderDirective, KeydownBinderDirective, KeysTypeBinderDirective, KeysdownBinderDirective, KeyupBinderDirective, LinearHistoryComponent, LongMousedownBinderDirective, LongTouchBinderDirective, MatChangeImpl, MatEvent, MatInteractionBase, MatSelectBinderDirective, MatSelectChangeTransition, MatSelectInteraction, MousedownBinderDirective, MouseenterBinderDirective, MouseleaveBinderDirective, MousemoveBinderDirective, MouseupBinderDirective, MultiTouchBinderDirective, OnDynamicDirective, PanBinderDirective, RedoBinderDirective, SelectBinderDirective, SwipeBinderDirective, TapBinderDirective, TestingInteractoModule, TextAreaBinderDirective, TextInputBinderDirective, TreeHistoryComponent, UndoBinderDirective, bindingsContextFactory, bindingsLinearUndoHistoryFactory, bindingsTreeUndoHistoryFactory, interactoProviders, interactoTreeUndoProviders, testingBindingsFactory, undoHistoryFactory };
//# sourceMappingURL=interacto-angular.mjs.map
