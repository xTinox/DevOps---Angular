import { Directive, EventEmitter, Host, Input, Optional, Output } from '@angular/core';
import { InteractoBinderDirective } from './interacto-binder-directive';
import * as i0 from "@angular/core";
import * as i1 from "./on-dynamic.directive";
import * as i2 from "interacto";
export class PanBinderDirective extends InteractoBinderDirective {
    constructor(onDyn, element, viewContainerRef, changeDetectorRef, bindings) {
        super(onDyn, element, viewContainerRef, changeDetectorRef);
        this.bindings = bindings;
        /**
         * Defines whether the pan is horizontal or vertical
         */
        this.horizontal = true;
        /**
         * The minimal distance from the starting point to the release point for validating the pan
         */
        this.minLength = 100;
        /**
         * The tolerance rate in pixels accepted while executing the pan
         */
        this.pxTolerance = 20;
        /**
         * The number of touches required to start the interaction
         */
        this.nbTouches = 1;
        this.panBinder = new EventEmitter();
    }
    /**
     * Starts the creation of a binding using the pan interaction.
     * @param fn - The function of the component that will be called to configure the binding.
     */
    set ioPan(fn) {
        this.callBinder(fn);
    }
    createPartialBinder() {
        return this.bindings.panBinder(this.horizontal, this.minLength, this.nbTouches, this.pxTolerance);
    }
    getOutputEvent() {
        return this.panBinder;
    }
}
PanBinderDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: PanBinderDirective, deps: [{ token: i1.OnDynamicDirective, host: true, optional: true }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i2.Bindings }], target: i0.ɵɵFactoryTarget.Directive });
PanBinderDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.4", type: PanBinderDirective, selector: "[ioPan]", inputs: { horizontal: "horizontal", minLength: "minLength", pxTolerance: "pxTolerance", nbTouches: "nbTouches", ioPan: "ioPan" }, outputs: { panBinder: "panBinder" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: PanBinderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ioPan]'
                }]
        }], ctorParameters: function () { return [{ type: i1.OnDynamicDirective, decorators: [{
                    type: Optional
                }, {
                    type: Host
                }] }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i2.Bindings }]; }, propDecorators: { panBinder: [{
                type: Output
            }], horizontal: [{
                type: Input
            }], minLength: [{
                type: Input
            }], pxTolerance: [{
                type: Input
            }], nbTouches: [{
                type: Input
            }], ioPan: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFuLWJpbmRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pbnRlcmFjdG8tYW5ndWxhci9zcmMvbGliL2RpcmVjdGl2ZXMvcGFuLWJpbmRlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFvQixTQUFTLEVBQWMsWUFBWSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBbUIsTUFBTSxlQUFlLENBQUM7QUFHdEksT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sOEJBQThCLENBQUM7Ozs7QUFLdEUsTUFBTSxPQUFPLGtCQUFtQixTQUFRLHdCQUE4RDtJQUlwRyxZQUFnQyxLQUF5QixFQUM3QyxPQUFnQyxFQUNoQyxnQkFBa0MsRUFDbEMsaUJBQW9DLEVBQzVCLFFBQW1DO1FBQ3JELEtBQUssQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFEekMsYUFBUSxHQUFSLFFBQVEsQ0FBMkI7UUFLdkQ7O1dBRUc7UUFFSCxlQUFVLEdBQUcsSUFBSSxDQUFDO1FBRWxCOztXQUVHO1FBRUgsY0FBUyxHQUFHLEdBQUcsQ0FBQztRQUVoQjs7V0FFRztRQUVILGdCQUFXLEdBQUcsRUFBRSxDQUFDO1FBRWpCOztXQUVHO1FBRUgsY0FBUyxHQUFHLENBQUMsQ0FBQztRQXpCWixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksWUFBWSxFQUEyQixDQUFDO0lBQy9ELENBQUM7SUEwQkQ7OztPQUdHO0lBQ0gsSUFDSSxLQUFLLENBQUMsRUFBeUo7UUFDakssSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRVMsbUJBQW1CO1FBQzNCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BHLENBQUM7SUFFUyxjQUFjO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDOzsrR0FwRFUsa0JBQWtCO21HQUFsQixrQkFBa0I7MkZBQWxCLGtCQUFrQjtrQkFIOUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsU0FBUztpQkFDcEI7OzBCQUtjLFFBQVE7OzBCQUFJLElBQUk7MkpBRlosU0FBUztzQkFEekIsTUFBTTtnQkFnQlAsVUFBVTtzQkFEVCxLQUFLO2dCQU9OLFNBQVM7c0JBRFIsS0FBSztnQkFPTixXQUFXO3NCQURWLEtBQUs7Z0JBT04sU0FBUztzQkFEUixLQUFLO2dCQVFGLEtBQUs7c0JBRFIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0LCBJbnB1dCwgT3B0aW9uYWwsIE91dHB1dCwgVmlld0NvbnRhaW5lclJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0JpbmRpbmcsIEJpbmRpbmdzLCBQYXJ0aWFsTXVsdGlUb3VjaEJpbmRlciwgVW5kb0hpc3RvcnlCYXNlfSBmcm9tICdpbnRlcmFjdG8nO1xuaW1wb3J0IHtPbkR5bmFtaWNEaXJlY3RpdmV9IGZyb20gJy4vb24tZHluYW1pYy5kaXJlY3RpdmUnO1xuaW1wb3J0IHtJbnRlcmFjdG9CaW5kZXJEaXJlY3RpdmV9IGZyb20gJy4vaW50ZXJhY3RvLWJpbmRlci1kaXJlY3RpdmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbaW9QYW5dJ1xufSlcbmV4cG9ydCBjbGFzcyBQYW5CaW5kZXJEaXJlY3RpdmUgZXh0ZW5kcyBJbnRlcmFjdG9CaW5kZXJEaXJlY3RpdmU8SFRNTEVsZW1lbnQsIFBhcnRpYWxNdWx0aVRvdWNoQmluZGVyPiB7XG4gIEBPdXRwdXQoKVxuICBwcml2YXRlIHJlYWRvbmx5IHBhbkJpbmRlcjogRXZlbnRFbWl0dGVyPFBhcnRpYWxNdWx0aVRvdWNoQmluZGVyPjtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASG9zdCgpIG9uRHluOiBPbkR5bmFtaWNEaXJlY3RpdmUsXG4gICAgICAgICAgICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICAgICAgICB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgYmluZGluZ3M6IEJpbmRpbmdzPFVuZG9IaXN0b3J5QmFzZT4pIHtcbiAgICBzdXBlcihvbkR5biwgZWxlbWVudCwgdmlld0NvbnRhaW5lclJlZiwgY2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIHRoaXMucGFuQmluZGVyID0gbmV3IEV2ZW50RW1pdHRlcjxQYXJ0aWFsTXVsdGlUb3VjaEJpbmRlcj4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhlIHBhbiBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAqL1xuICBASW5wdXQoKVxuICBob3Jpem9udGFsID0gdHJ1ZTtcblxuICAvKipcbiAgICogVGhlIG1pbmltYWwgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnRpbmcgcG9pbnQgdG8gdGhlIHJlbGVhc2UgcG9pbnQgZm9yIHZhbGlkYXRpbmcgdGhlIHBhblxuICAgKi9cbiAgQElucHV0KClcbiAgbWluTGVuZ3RoID0gMTAwO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9sZXJhbmNlIHJhdGUgaW4gcGl4ZWxzIGFjY2VwdGVkIHdoaWxlIGV4ZWN1dGluZyB0aGUgcGFuXG4gICAqL1xuICBASW5wdXQoKVxuICBweFRvbGVyYW5jZSA9IDIwO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHRvdWNoZXMgcmVxdWlyZWQgdG8gc3RhcnQgdGhlIGludGVyYWN0aW9uXG4gICAqL1xuICBASW5wdXQoKVxuICBuYlRvdWNoZXMgPSAxO1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGNyZWF0aW9uIG9mIGEgYmluZGluZyB1c2luZyB0aGUgcGFuIGludGVyYWN0aW9uLlxuICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIGNvbmZpZ3VyZSB0aGUgYmluZGluZy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBpb1BhbihmbjogKChwYXJ0aWFsQmluZGVyOiBQYXJ0aWFsTXVsdGlUb3VjaEJpbmRlciwgd2lkZ2V0OiBIVE1MRWxlbWVudCkgPT4gQmluZGluZzxhbnksIGFueSwgYW55PiB8IEFycmF5PEJpbmRpbmc8YW55LCBhbnksIGFueT4+IHwgdm9pZCkgfCB1bmRlZmluZWQgfCBzdHJpbmcpICB7XG4gICAgdGhpcy5jYWxsQmluZGVyKGZuKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjcmVhdGVQYXJ0aWFsQmluZGVyKCk6IFBhcnRpYWxNdWx0aVRvdWNoQmluZGVyIHtcbiAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5wYW5CaW5kZXIodGhpcy5ob3Jpem9udGFsLCB0aGlzLm1pbkxlbmd0aCwgdGhpcy5uYlRvdWNoZXMsIHRoaXMucHhUb2xlcmFuY2UpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldE91dHB1dEV2ZW50KCk6IEV2ZW50RW1pdHRlcjxQYXJ0aWFsTXVsdGlUb3VjaEJpbmRlcj4ge1xuICAgIHJldHVybiB0aGlzLnBhbkJpbmRlcjtcbiAgfVxufVxuIl19