import { ChangeDetectionStrategy, Component, HostBinding, Input } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "interacto";
import * as i2 from "@angular/common";
import * as i3 from "../../directives/click-binder.directive";
import * as i4 from "../../directives/undo-binder.directive";
import * as i5 from "../../directives/redo-binder.directive";
/**
 * The Angular component for display a tree-based undo/redo history
 */
export class TreeHistoryComponent {
    constructor(history, changeDetect) {
        this.history = history;
        this.changeDetect = changeDetect;
        this.svgViewportWidth = 50;
        this.svgViewportHeight = 50;
        this.svgIconSize = 50;
        this.rootRenderer = undefined;
        this.widthcss = "";
        this.cache = {};
        // Only updating the view on history changes
        this.subscriptionUndos = history.undosObservable().subscribe(() => {
            changeDetect.detectChanges();
        });
        this.subscriptionRedos = history.redosObservable().subscribe(() => {
            changeDetect.detectChanges();
        });
    }
    ngAfterViewInit() {
        // Preventing the input attributes to update the view
        this.changeDetect.detach();
    }
    ngOnDestroy() {
        this.subscriptionUndos.unsubscribe();
        this.subscriptionRedos.unsubscribe();
    }
    depth(undoableNode) {
        let depth = -1;
        let n = undoableNode;
        while (n !== undefined) {
            depth++;
            n = n.parent;
        }
        return Math.max(0, depth);
    }
    createHtmlTag(snapshot, div, svg) {
        div.querySelectorAll('div')[0]?.remove();
        const size = `${this.svgIconSize}px`;
        const divpic = document.createElement("div");
        divpic.appendChild(snapshot);
        divpic.style.width = size;
        divpic.style.height = size;
        if (svg) {
            snapshot.setAttribute("viewBox", `0 0 ${this.svgViewportWidth} ${this.svgViewportHeight}`);
        }
        snapshot.setAttribute("width", size);
        snapshot.setAttribute("height", size);
        div.appendChild(divpic);
    }
    undoButtonSnapshot_(snapshot, txt, div) {
        if (typeof snapshot === 'string') {
            return `${txt}: ${snapshot}`;
        }
        if (snapshot instanceof SVGElement) {
            this.createHtmlTag(snapshot, div, true);
            return txt;
        }
        if (snapshot instanceof HTMLElement) {
            this.createHtmlTag(snapshot, div, false);
            return undefined;
        }
        return txt;
    }
    undoButtonSnapshot(node, div) {
        if (node === undefined) {
            if (this.cacheRoot === undefined) {
                this.cacheRoot = this.rootRenderer;
            }
        }
        else {
            if (this.cache[node.id] === undefined) {
                this.cache[node.id] = node.visualSnapshot;
            }
        }
        const snapshot = node === undefined ? this.cacheRoot : this.cache[node.id];
        const txt = node === undefined ? "Root" : node.undoable.getUndoName();
        if (snapshot === undefined) {
            return txt;
        }
        if (snapshot instanceof Promise) {
            void snapshot.then((res) => {
                if (node !== undefined) {
                    this.cache[node.id] = res;
                }
                else {
                    this.cacheRoot = res;
                }
                return this.undoButtonSnapshot_(res, txt, div);
            });
            return txt;
        }
        if (node?.id === this.history.currentNode.id) {
            div.scrollIntoView();
        }
        return this.undoButtonSnapshot_(snapshot, txt, div);
    }
    clickBinders(binder, position) {
        return [
            binder
                .toProduceAnon(() => {
                this.history.goTo(position);
            })
                .when(i => i.button === 0)
                .bind(),
            binder
                .toProduceAnon(() => {
                this.history.delete(position);
            })
                .when(i => !this.history.keepPath && i.button === 2)
                .ifHadEffects(() => {
                this.changeDetect.detectChanges();
            })
                .bind()
        ];
    }
    getTop(position) {
        return this.depth(this.history.undoableNodes[position.key]) * (this.svgIconSize + 10) + 10;
    }
    getLeft(position) {
        return position.value * (this.svgIconSize + 10) + 10;
    }
}
TreeHistoryComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TreeHistoryComponent, deps: [{ token: i1.TreeUndoHistory }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
TreeHistoryComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.4", type: TreeHistoryComponent, selector: "io-tree-history", inputs: { width: "width", svgViewportWidth: "svgViewportWidth", svgViewportHeight: "svgViewportHeight", svgIconSize: "svgIconSize", rootRenderer: "rootRenderer" }, host: { properties: { "style.width": "this.widthcss" } }, ngImport: i0, template: "<div class=\"header\">\n  <h2>HISTORY</h2>\n  <button ioUndo class=\"button-undo-redo\">undo</button>\n  <button ioRedo class=\"button-undo-redo\">redo</button>\n</div>\n\n<div class=\"tree\" oncontextmenu=\"return false;\">\n  <div #d class=\"tree-node-history\" *ngFor=\"let position of history.getPositions() | keyvalue\"\n       [ngStyle]=\"{left: getLeft(position) + 'px', top: getTop(position) + 'px'}\"\n       [ngClass]=\"history.currentNode.id === position.key ? 'current-node' : ''\"\n       [ioClick] (clickBinder)=\"clickBinders($event, position.key)\">\n    {{undoButtonSnapshot(history.undoableNodes[position.key], d)}}\n  </div>\n</div>\n", styles: [".header{background-color:#000;min-height:75px;border-bottom-style:solid}.header h2{font-size:25px;text-align:center;padding-top:25px;padding-bottom:25px;margin:0;color:#fff}.tree-node-history{position:absolute;padding:0;border-style:solid;color:#000;background-color:#fff;border-width:thin;-webkit-user-select:none;user-select:none}.button-undo-redo{width:50%;min-height:40px;border-right-style:solid;border-left-style:solid;color:#000;background-color:#fff;border-width:thin;font-size:20px}.header button:disabled{width:50%;border-right-style:solid;border-left-style:solid;color:#000;background-color:#d3d3d3;border-width:thin;font-size:20px}.current-node{background-color:#708090}.tree{overflow:auto;width:inherit;height:inherit;position:fixed}\n"], dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i3.ClickBinderDirective, selector: "[ioClick]", inputs: ["ioClick"], outputs: ["clickBinder"] }, { kind: "directive", type: i4.UndoBinderDirective, selector: "button:ioUndo,button:[ioUndo]", inputs: ["ioUndo"] }, { kind: "directive", type: i5.RedoBinderDirective, selector: "button:ioRedo,button:[ioRedo]", inputs: ["ioRedo"] }, { kind: "pipe", type: i2.KeyValuePipe, name: "keyvalue" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.4", ngImport: i0, type: TreeHistoryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'io-tree-history', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"header\">\n  <h2>HISTORY</h2>\n  <button ioUndo class=\"button-undo-redo\">undo</button>\n  <button ioRedo class=\"button-undo-redo\">redo</button>\n</div>\n\n<div class=\"tree\" oncontextmenu=\"return false;\">\n  <div #d class=\"tree-node-history\" *ngFor=\"let position of history.getPositions() | keyvalue\"\n       [ngStyle]=\"{left: getLeft(position) + 'px', top: getTop(position) + 'px'}\"\n       [ngClass]=\"history.currentNode.id === position.key ? 'current-node' : ''\"\n       [ioClick] (clickBinder)=\"clickBinders($event, position.key)\">\n    {{undoButtonSnapshot(history.undoableNodes[position.key], d)}}\n  </div>\n</div>\n", styles: [".header{background-color:#000;min-height:75px;border-bottom-style:solid}.header h2{font-size:25px;text-align:center;padding-top:25px;padding-bottom:25px;margin:0;color:#fff}.tree-node-history{position:absolute;padding:0;border-style:solid;color:#000;background-color:#fff;border-width:thin;-webkit-user-select:none;user-select:none}.button-undo-redo{width:50%;min-height:40px;border-right-style:solid;border-left-style:solid;color:#000;background-color:#fff;border-width:thin;font-size:20px}.header button:disabled{width:50%;border-right-style:solid;border-left-style:solid;color:#000;background-color:#d3d3d3;border-width:thin;font-size:20px}.current-node{background-color:#708090}.tree{overflow:auto;width:inherit;height:inherit;position:fixed}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.TreeUndoHistory }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { width: [{
                type: Input
            }], svgViewportWidth: [{
                type: Input
            }], svgViewportHeight: [{
                type: Input
            }], svgIconSize: [{
                type: Input
            }], rootRenderer: [{
                type: Input
            }], widthcss: [{
                type: HostBinding,
                args: ['style.width']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1oaXN0b3J5LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2ludGVyYWN0by1hbmd1bGFyL3NyYy9saWIvY29tcG9uZW50cy90cmVlLWhpc3RvcnkvdHJlZS1oaXN0b3J5LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2ludGVyYWN0by1hbmd1bGFyL3NyYy9saWIvY29tcG9uZW50cy90cmVlLWhpc3RvcnkvdHJlZS1oaXN0b3J5LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBRU4sTUFBTSxlQUFlLENBQUM7Ozs7Ozs7QUFNdkI7O0dBRUc7QUFPSCxNQUFNLE9BQU8sb0JBQW9CO0lBNEIvQixZQUEwQixPQUF3QixFQUN2QixZQUErQjtRQURoQyxZQUFPLEdBQVAsT0FBTyxDQUFpQjtRQUN2QixpQkFBWSxHQUFaLFlBQVksQ0FBbUI7UUF4Qm5ELHFCQUFnQixHQUFXLEVBQUUsQ0FBQztRQUc5QixzQkFBaUIsR0FBVyxFQUFFLENBQUM7UUFHL0IsZ0JBQVcsR0FBVyxFQUFFLENBQUM7UUFHekIsaUJBQVksR0FBcUIsU0FBUyxDQUFDO1FBR2xELGFBQVEsR0FBRyxFQUFFLENBQUM7UUFFUCxVQUFLLEdBQTRCLEVBQUUsQ0FBQztRQVd6Qyw0Q0FBNEM7UUFDNUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ2hFLFlBQVksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUMvQixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxpQkFBaUIsR0FBRyxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUNoRSxZQUFZLENBQUMs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Z0JBSUMsZ0JBQWdCO3NCQUR0QixLQUFLO2dCQUlDLGlCQUFpQjtzQkFEdkIsS0FBSztnQkFJQyxXQUFXO3NCQURqQixLQUFLO2dCQUlDLFlBQVk7c0JBRGxCLEtBQUs7Z0JBSU4sUUFBUTtzQkFEUCxXQUFXO3VCQUFDLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgSG9zdEJpbmRpbmcsXG4gIElucHV0LFxuICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0JpbmRpbmcsIFBhcnRpYWxQb2ludEJpbmRlciwgVHJlZVVuZG9IaXN0b3J5LCBVbmRvYWJsZVRyZWVOb2RlfSBmcm9tICdpbnRlcmFjdG8nO1xuaW1wb3J0IHtLZXlWYWx1ZX0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vblwiO1xuaW1wb3J0IHtVbmRvYWJsZVNuYXBzaG90fSBmcm9tIFwiaW50ZXJhY3RvL2Rpc3QvYXBpL3VuZG8vVW5kb2FibGVcIjtcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tIFwicnhqc1wiO1xuXG4vKipcbiAqIFRoZSBBbmd1bGFyIGNvbXBvbmVudCBmb3IgZGlzcGxheSBhIHRyZWUtYmFzZWQgdW5kby9yZWRvIGhpc3RvcnlcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnaW8tdHJlZS1oaXN0b3J5JyxcbiAgdGVtcGxhdGVVcmw6ICcuL3RyZWUtaGlzdG9yeS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3RyZWUtaGlzdG9yeS5jb21wb25lbnQuY3NzJ10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFRyZWVIaXN0b3J5Q29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlclZpZXdJbml0IHtcbiAgQElucHV0KClcbiAgcHVibGljIHdpZHRoPzogc3RyaW5nO1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBzdmdWaWV3cG9ydFdpZHRoOiBudW1iZXIgPSA1MDtcblxuICBASW5wdXQoKVxuICBwdWJsaWMgc3ZnVmlld3BvcnRIZWlnaHQ6IG51bWJlciA9IDUwO1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBzdmdJY29uU2l6ZTogbnVtYmVyID0gNTA7XG5cbiAgQElucHV0KClcbiAgcHVibGljIHJvb3RSZW5kZXJlcjogVW5kb2FibGVTbmFwc2hvdCA9IHVuZGVmaW5lZDtcblxuICBASG9zdEJpbmRpbmcoJ3N0eWxlLndpZHRoJylcbiAgd2lkdGhjc3MgPSBcIlwiO1xuXG4gIHB1YmxpYyBjYWNoZTogUmVjb3JkPG51bWJlciwgdW5rbm93bj4gPSB7fTtcblxuICBwdWJsaWMgY2FjaGVSb290OiB1bmtub3duIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uVW5kb3M6IFN1YnNjcmlwdGlvbjtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvblJlZG9zOiBTdWJzY3JpcHRpb247XG5cblxuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIGhpc3Rvcnk6IFRyZWVVbmRvSGlzdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0OiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIC8vIE9ubHkgdXBkYXRpbmcgdGhlIHZpZXcgb24gaGlzdG9yeSBjaGFuZ2VzXG4gICAgdGhpcy5zdWJzY3JpcHRpb25VbmRvcyA9IGhpc3RvcnkudW5kb3NPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNoYW5nZURldGVjdC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvblJlZG9zID0gaGlzdG9yeS5yZWRvc09ic2VydmFibGUoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY2hhbmdlRGV0ZWN0LmRldGVjdENoYW5nZXMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gUHJldmVudGluZyB0aGUgaW5wdXQgYXR0cmlidXRlcyB0byB1cGRhdGUgdGhlIHZpZXdcbiAgICB0aGlzLmNoYW5nZURldGVjdC5kZXRhY2goKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvblVuZG9zLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25SZWRvcy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHVibGljIGRlcHRoKHVuZG9hYmxlTm9kZTogVW5kb2FibGVUcmVlTm9kZSB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gICAgbGV0IGRlcHRoID0gLTE7XG4gICAgbGV0IG4gPSB1bmRvYWJsZU5vZGU7XG5cbiAgICB3aGlsZSAobiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXB0aCsrO1xuICAgICAgbiA9IG4ucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBkZXB0aCk7XG4gIH1cblxuXG4gIHByaXZhdGUgY3JlYXRlSHRtbFRhZyhzbmFwc2hvdDogRWxlbWVudCwgZGl2OiBIVE1MRGl2RWxlbWVudCwgc3ZnOiBib29sZWFuKTogdm9pZCB7XG4gICAgZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ2RpdicpWzBdPy5yZW1vdmUoKTtcbiAgICBjb25zdCBzaXplID0gYCR7dGhpcy5zdmdJY29uU2l6ZX1weGA7XG4gICAgY29uc3QgZGl2cGljID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXZwaWMuYXBwZW5kQ2hpbGQoc25hcHNob3QpO1xuICAgIGRpdnBpYy5zdHlsZS53aWR0aCA9IHNpemU7XG4gICAgZGl2cGljLnN0eWxlLmhlaWdodCA9IHNpemU7XG5cbiAgICBpZiAoc3ZnKSB7XG4gICAgICBzbmFwc2hvdC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt0aGlzLnN2Z1ZpZXdwb3J0V2lkdGh9ICR7dGhpcy5zdmdWaWV3cG9ydEhlaWdodH1gKTtcbiAgICB9XG5cbiAgICBzbmFwc2hvdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBzaXplKTtcbiAgICBzbmFwc2hvdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc2l6ZSk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGRpdnBpYyk7XG4gIH1cblxuXG4gIHByaXZhdGUgdW5kb0J1dHRvblNuYXBzaG90XyhzbmFwc2hvdDogdW5rbm93bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4dDogc3RyaW5nLCBkaXY6IEhUTUxEaXZFbGVtZW50KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodHlwZW9mIHNuYXBzaG90ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGAke3R4dH06ICR7c25hcHNob3R9YDtcbiAgICB9XG5cbiAgICBpZiAoc25hcHNob3QgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICB0aGlzLmNyZWF0ZUh0bWxUYWcoc25hcHNob3QsIGRpdiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHh0O1xuICAgIH1cblxuICAgIGlmIChzbmFwc2hvdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0aGlzLmNyZWF0ZUh0bWxUYWcoc25hcHNob3QsIGRpdiwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHh0O1xuICB9XG5cbiAgcHVibGljIHVuZG9CdXR0b25TbmFwc2hvdChub2RlOiBVbmRvYWJsZVRyZWVOb2RlIHwgdW5kZWZpbmVkLCBkaXY6IEhUTUxEaXZFbGVtZW50KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBpZihub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLmNhY2hlUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2FjaGVSb290ID0gdGhpcy5yb290UmVuZGVyZXI7XG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgaWYgKHRoaXMuY2FjaGVbbm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNhY2hlW25vZGUuaWRdID0gbm9kZS52aXN1YWxTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzbmFwc2hvdCA9IG5vZGUgPT09IHVuZGVmaW5lZCA/IHRoaXMuY2FjaGVSb290IDogdGhpcy5jYWNoZVtub2RlLmlkXTtcbiAgICBjb25zdCB0eHQgPSBub2RlID09PSB1bmRlZmluZWQgPyBcIlJvb3RcIiA6IG5vZGUudW5kb2FibGUuZ2V0VW5kb05hbWUoKTtcblxuICAgIGlmIChzbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHh0O1xuICAgIH1cblxuICAgIGlmIChzbmFwc2hvdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHZvaWQgc25hcHNob3QudGhlbigocmVzOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlW25vZGUuaWRdID0gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FjaGVSb290ID0gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVuZG9CdXR0b25TbmFwc2hvdF8ocmVzLCB0eHQsIGRpdik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0eHQ7XG4gICAgfVxuXG4gICAgaWYobm9kZT8uaWQgPT09IHRoaXMuaGlzdG9yeS5jdXJyZW50Tm9kZS5pZCkge1xuICAgICAgZGl2LnNjcm9sbEludG9WaWV3KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudW5kb0J1dHRvblNuYXBzaG90XyhzbmFwc2hvdCwgdHh0LCBkaXYpO1xuICB9XG5cblxuICBwdWJsaWMgY2xpY2tCaW5kZXJzKGJpbmRlcjogUGFydGlhbFBvaW50QmluZGVyLCBwb3NpdGlvbjogbnVtYmVyKTogQXJyYXk8QmluZGluZzxhbnksIGFueSwgYW55Pj4ge1xuICAgIHJldHVybiBbXG4gICAgICBiaW5kZXJcbiAgICAgICAgLnRvUHJvZHVjZUFub24oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGlzdG9yeS5nb1RvKHBvc2l0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLndoZW4oaSA9PiBpLmJ1dHRvbiA9PT0gMClcbiAgICAgICAgLmJpbmQoKSxcbiAgICAgIGJpbmRlclxuICAgICAgICAudG9Qcm9kdWNlQW5vbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5LmRlbGV0ZShwb3NpdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC53aGVuKGkgPT4gIXRoaXMuaGlzdG9yeS5rZWVwUGF0aCAmJiBpLmJ1dHRvbiA9PT0gMilcbiAgICAgICAgLmlmSGFkRWZmZWN0cygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9KVxuICAgICAgICAuYmluZCgpXG4gICAgXTtcbiAgfVxuXG5cbiAgcHVibGljIGdldFRvcChwb3NpdGlvbjogS2V5VmFsdWU8bnVtYmVyLCBudW1iZXI+KTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aCh0aGlzLmhpc3RvcnkudW5kb2FibGVOb2Rlc1twb3NpdGlvbi5rZXldKSAqICh0aGlzLnN2Z0ljb25TaXplICsgMTApICsgMTA7XG4gIH1cblxuICBwdWJsaWMgZ2V0TGVmdChwb3NpdGlvbjogS2V5VmFsdWU8bnVtYmVyLCBudW1iZXI+KTogbnVtYmVyIHtcbiAgICByZXR1cm4gcG9zaXRpb24udmFsdWUgKiAodGhpcy5zdmdJY29uU2l6ZSArIDEwKSArIDEwO1xuICB9XG59XG4iLCI8ZGl2IGNsYXNzPVwiaGVhZGVyXCI+XG4gIDxoMj5ISVNUT1JZPC9oMj5cbiAgPGJ1dHRvbiBpb1VuZG8gY2xhc3M9XCJidXR0b24tdW5kby1yZWRvXCI+dW5kbzwvYnV0dG9uPlxuICA8YnV0dG9uIGlvUmVkbyBjbGFzcz1cImJ1dHRvbi11bmRvLXJlZG9cIj5yZWRvPC9idXR0b24+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cInRyZWVcIiBvbmNvbnRleHRtZW51PVwicmV0dXJuIGZhbHNlO1wiPlxuICA8ZGl2ICNkIGNsYXNzPVwidHJlZS1ub2RlLWhpc3RvcnlcIiAqbmdGb3I9XCJsZXQgcG9zaXRpb24gb2YgaGlzdG9yeS5nZXRQb3NpdGlvbnMoKSB8IGtleXZhbHVlXCJcbiAgICAgICBbbmdTdHlsZV09XCJ7bGVmdDogZ2V0TGVmdChwb3NpdGlvbikgKyAncHgnLCB0b3A6IGdldFRvcChwb3NpdGlvbikgKyAncHgnfVwiXG4gICAgICAgW25nQ2xhc3NdPVwiaGlzdG9yeS5jdXJyZW50Tm9kZS5pZCA9PT0gcG9zaXRpb24ua2V5ID8gJ2N1cnJlbnQtbm9kZScgOiAnJ1wiXG4gICAgICAgW2lvQ2xpY2tdIChjbGlja0JpbmRlcik9XCJjbGlja0JpbmRlcnMoJGV2ZW50LCBwb3NpdGlvbi5rZXkpXCI+XG4gICAge3t1bmRvQnV0dG9uU25hcHNob3QoaGlzdG9yeS51bmRvYWJsZU5vZGVzW3Bvc2l0aW9uLmtleV0sIGQpfX1cbiAgPC9kaXY+XG48L2Rpdj5cbiJdfQ==